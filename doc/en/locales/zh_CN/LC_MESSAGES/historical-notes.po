# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, holger krekel and pytest-dev team
# This file is distributed under the same license as the pytest package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pytest 7.1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-12 11:35+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../../en/historical-notes.rst:2
msgid "Historical Notes"
msgstr ""

#: ../../../en/historical-notes.rst:4
msgid ""
"This page lists features or behavior from previous versions of pytest "
"which have changed over the years. They are kept here as a historical "
"note so users looking at old code can find documentation related to them."
msgstr ""

#: ../../../en/historical-notes.rst:11
msgid "Marker revamp and iteration"
msgstr ""

#: ../../../en/historical-notes.rst:15
msgid ""
"pytest's marker implementation traditionally worked by simply updating "
"the ``__dict__`` attribute of functions to cumulatively add markers. As a"
" result, markers would unintentionally be passed along class hierarchies "
"in surprising ways. Further, the API for retrieving them was "
"inconsistent, as markers from parameterization would be stored "
"differently than markers applied using the ``@pytest.mark`` decorator and"
" markers added via ``node.add_marker``."
msgstr ""

#: ../../../en/historical-notes.rst:17
msgid ""
"This state of things made it technically next to impossible to use data "
"from markers correctly without having a deep understanding of the "
"internals, leading to subtle and hard to understand bugs in more advanced"
" usages."
msgstr ""

#: ../../../en/historical-notes.rst:19
msgid ""
"Depending on how a marker got declared/changed one would get either a "
"``MarkerInfo`` which might contain markers from sibling classes, "
"``MarkDecorators`` when marks came from parameterization or from a "
"``node.add_marker`` call, discarding prior marks. Also ``MarkerInfo`` "
"acts like a single mark, when it in fact represents a merged view on "
"multiple marks with the same name."
msgstr ""

#: ../../../en/historical-notes.rst:22
msgid ""
"On top of that markers were not accessible in the same way for modules, "
"classes, and functions/methods. In fact, markers were only accessible in "
"functions, even if they were declared on classes/modules."
msgstr ""

#: ../../../en/historical-notes.rst:25
msgid ""
"A new API to access markers has been introduced in pytest 3.6 in order to"
" solve the problems with the initial design, providing the "
":func:`_pytest.nodes.Node.iter_markers` method to iterate over markers in"
" a consistent manner and reworking the internals, which solved a great "
"deal of problems with the initial design."
msgstr ""

#: ../../../en/historical-notes.rst:34
msgid "Updating code"
msgstr ""

#: ../../../en/historical-notes.rst:36
msgid ""
"The old ``Node.get_marker(name)`` function is considered deprecated "
"because it returns an internal ``MarkerInfo`` object which contains the "
"merged name, ``*args`` and ``**kwargs`` of all the markers which apply to"
" that node."
msgstr ""

#: ../../../en/historical-notes.rst:39
msgid "In general there are two scenarios on how markers should be handled:"
msgstr ""

#: ../../../en/historical-notes.rst:41
msgid ""
"1. Marks overwrite each other. Order matters but you only want to think "
"of your mark as a single item. E.g. ``log_level('info')`` at a module "
"level can be overwritten by ``log_level('debug')`` for a specific test."
msgstr ""

#: ../../../en/historical-notes.rst:44
msgid "In this case, use ``Node.get_closest_marker(name)``:"
msgstr ""

#: ../../../en/historical-notes.rst:58
msgid ""
"2. Marks compose in an additive manner. E.g. ``skipif(condition)`` marks "
"mean you just want to evaluate all of them, order doesn't even matter. "
"You probably want to think of your marks as a set here."
msgstr ""

#: ../../../en/historical-notes.rst:61
msgid ""
"In this case iterate over each mark and handle their ``*args`` and "
"``**kwargs`` individually."
msgstr ""

#: ../../../en/historical-notes.rst:78
msgid ""
"If you are unsure or have any questions, please consider opening "
":issue:`an issue <new>`."
msgstr ""

#: ../../../en/historical-notes.rst:82
msgid "Related issues"
msgstr ""

#: ../../../en/historical-notes.rst:84
msgid "Here is a non-exhaustive list of issues fixed by the new implementation:"
msgstr ""

#: ../../../en/historical-notes.rst:86
msgid "Marks don't pick up nested classes (:issue:`199`)."
msgstr ""

#: ../../../en/historical-notes.rst:88
msgid "Markers stain on all related classes (:issue:`568`)."
msgstr ""

#: ../../../en/historical-notes.rst:90
msgid "Combining marks - args and kwargs calculation (:issue:`2897`)."
msgstr ""

#: ../../../en/historical-notes.rst:92
msgid ""
"``request.node.get_marker('name')`` returns ``None`` for markers applied "
"in classes (:issue:`902`)."
msgstr ""

#: ../../../en/historical-notes.rst:94
msgid "Marks applied in parametrize are stored as markdecorator (:issue:`2400`)."
msgstr ""

#: ../../../en/historical-notes.rst:96
msgid "Fix marker interaction in a backward incompatible way (:issue:`1670`)."
msgstr ""

#: ../../../en/historical-notes.rst:98
msgid ""
"Refactor marks to get rid of the current \"marks transfer\" mechanism "
"(:issue:`2363`)."
msgstr ""

#: ../../../en/historical-notes.rst:100
msgid ""
"Introduce FunctionDefinition node, use it in generate_tests "
"(:issue:`2522`)."
msgstr ""

#: ../../../en/historical-notes.rst:102
msgid ""
"Remove named marker attributes and collect markers in items "
"(:issue:`891`)."
msgstr ""

#: ../../../en/historical-notes.rst:104
msgid ""
"skipif mark from parametrize hides module level skipif mark "
"(:issue:`1540`)."
msgstr ""

#: ../../../en/historical-notes.rst:106
msgid "skipif + parametrize not skipping tests (:issue:`1296`)."
msgstr ""

#: ../../../en/historical-notes.rst:108
msgid "Marker transfer incompatible with inheritance (:issue:`535`)."
msgstr ""

#: ../../../en/historical-notes.rst:110
msgid "More details can be found in the :pull:`original PR <3317>`."
msgstr ""

#: ../../../en/historical-notes.rst:114
msgid ""
"in a future major release of pytest we will introduce class based "
"markers, at which point markers will no longer be limited to instances of"
" :py:class:`~_pytest.mark.Mark`."
msgstr ""

#: ../../../en/historical-notes.rst:119
msgid "cache plugin integrated into the core"
msgstr ""

#: ../../../en/historical-notes.rst:123
msgid ""
"The functionality of the :ref:`core cache <cache>` plugin was previously "
"distributed as a third party plugin named ``pytest-cache``.  The core "
"plugin is compatible regarding command line options and API usage except "
"that you can only store/receive data between test runs that is json-"
"serializable."
msgstr ""

#: ../../../en/historical-notes.rst:131
msgid "funcargs and ``pytest_funcarg__``"
msgstr ""

#: ../../../en/historical-notes.rst:135
msgid ""
"In versions prior to 2.3 there was no ``@pytest.fixture`` marker and you "
"had to use a magic ``pytest_funcarg__NAME`` prefix for the fixture "
"factory.  This remains and will remain supported but is not anymore "
"advertised as the primary means of declaring fixture functions."
msgstr ""

#: ../../../en/historical-notes.rst:143
msgid "``@pytest.yield_fixture`` decorator"
msgstr ""

#: ../../../en/historical-notes.rst:147
msgid ""
"Prior to version 2.10, in order to use a ``yield`` statement to execute "
"teardown code one had to mark a fixture using the ``yield_fixture`` "
"marker. From 2.10 onward, normal fixtures can use ``yield`` directly so "
"the ``yield_fixture`` decorator is no longer needed and considered "
"deprecated."
msgstr ""

#: ../../../en/historical-notes.rst:154
msgid "``[pytest]`` header in ``setup.cfg``"
msgstr ""

#: ../../../en/historical-notes.rst:158
msgid ""
"Prior to 3.0, the supported section name was ``[pytest]``. Due to how "
"this may collide with some distutils commands, the recommended section "
"name for ``setup.cfg`` files is now ``[tool:pytest]``."
msgstr ""

#: ../../../en/historical-notes.rst:162
msgid ""
"Note that for ``pytest.ini`` and ``tox.ini`` files the section name is "
"``[pytest]``."
msgstr ""

#: ../../../en/historical-notes.rst:167
msgid "Applying marks to ``@pytest.mark.parametrize`` parameters"
msgstr ""

#: ../../../en/historical-notes.rst:171
msgid ""
"Prior to version 3.1 the supported mechanism for marking values used the "
"syntax:"
msgstr ""

#: ../../../en/historical-notes.rst:186
msgid ""
"This was an initial hack to support the feature but soon was demonstrated"
" to be incomplete, broken for passing functions or applying multiple "
"marks with the same name but different parameters."
msgstr ""

#: ../../../en/historical-notes.rst:189
msgid "The old syntax is planned to be removed in pytest-4.0."
msgstr ""

#: ../../../en/historical-notes.rst:193
msgid "``@pytest.mark.parametrize`` argument names as a tuple"
msgstr ""

#: ../../../en/historical-notes.rst:197
msgid ""
"In versions prior to 2.4 one needed to specify the argument names as a "
"tuple.  This remains valid but the simpler ``\"name1,name2,...\"`` comma-"
"separated-string syntax is now advertised first because it's easier to "
"write and produces less line noise."
msgstr ""

#: ../../../en/historical-notes.rst:204
msgid "setup: is now an \"autouse fixture\""
msgstr ""

#: ../../../en/historical-notes.rst:208
msgid ""
"During development prior to the pytest-2.3 release the name "
"``pytest.setup`` was used but before the release it was renamed and moved"
" to become part of the general fixture mechanism, namely :ref:`autouse "
"fixtures`"
msgstr ""

#: ../../../en/historical-notes.rst:217
msgid "Conditions as strings instead of booleans"
msgstr ""

#: ../../../en/historical-notes.rst:221
msgid ""
"Prior to pytest-2.4 the only way to specify skipif/xfail conditions was "
"to use strings:"
msgstr ""

#: ../../../en/historical-notes.rst:233
msgid ""
"During test function setup the skipif condition is evaluated by calling "
"``eval('sys.version_info >= (3,0)', namespace)``.  The namespace contains"
" all the module globals, and ``os`` and ``sys`` as a minimum."
msgstr ""

#: ../../../en/historical-notes.rst:237
msgid ""
"Since pytest-2.4 :ref:`boolean conditions <condition booleans>` are "
"considered preferable because markers can then be freely imported between"
" test modules. With strings you need to import not only the marker but "
"all variables used by the marker, which violates encapsulation."
msgstr ""

#: ../../../en/historical-notes.rst:242
msgid ""
"The reason for specifying the condition as a string was that ``pytest`` "
"can report a summary of skip conditions based purely on the condition "
"string. With conditions as booleans you are required to specify a "
"``reason`` string."
msgstr ""

#: ../../../en/historical-notes.rst:246
msgid ""
"Note that string conditions will remain fully supported and you are free "
"to use them if you have no need for cross-importing markers."
msgstr ""

#: ../../../en/historical-notes.rst:249
msgid ""
"The evaluation of a condition string in "
"``pytest.mark.skipif(conditionstring)`` or "
"``pytest.mark.xfail(conditionstring)`` takes place in a namespace "
"dictionary which is constructed as follows:"
msgstr ""

#: ../../../en/historical-notes.rst:253
msgid ""
"the namespace is initialized by putting the ``sys`` and ``os`` modules "
"and the pytest ``config`` object into it."
msgstr ""

#: ../../../en/historical-notes.rst:256
msgid ""
"updated with the module globals of the test function for which the "
"expression is applied."
msgstr ""

#: ../../../en/historical-notes.rst:259
msgid ""
"The pytest ``config`` object allows you to skip based on a test "
"configuration value which you might have added:"
msgstr ""

#: ../../../en/historical-notes.rst:268
msgid "The equivalent with \"boolean conditions\" is:"
msgstr ""

#: ../../../en/historical-notes.rst:278
msgid ""
"You cannot use ``pytest.config.getvalue()`` in code imported before "
"pytest's argument parsing takes place.  For example, ``conftest.py`` "
"files are imported before command line parsing and thus "
"``config.getvalue()`` will not execute correctly."
msgstr ""

#: ../../../en/historical-notes.rst:284
msgid "``pytest.set_trace()``"
msgstr ""

#: ../../../en/historical-notes.rst:288
msgid ""
"Previous to version 2.4 to set a break point in code one needed to use "
"``pytest.set_trace()``:"
msgstr ""

#: ../../../en/historical-notes.rst:300
msgid ""
"This is no longer needed and one can use the native ``import "
"pdb;pdb.set_trace()`` call directly."
msgstr ""

#: ../../../en/historical-notes.rst:302
msgid "For more details see :ref:`breakpoints`."
msgstr ""

#: ../../../en/historical-notes.rst:305
msgid "\"compat\" properties"
msgstr ""

#: ../../../en/historical-notes.rst:309
msgid ""
"Access of ``Module``, ``Function``, ``Class``, ``Instance``, ``File`` and"
" ``Item`` through ``Node`` instances have long been documented as "
"deprecated, but started to emit warnings from pytest ``3.9`` and onward."
msgstr ""

#: ../../../en/historical-notes.rst:312
msgid ""
"Users should just ``import pytest`` and access those objects using the "
"``pytest`` module."
msgstr ""

