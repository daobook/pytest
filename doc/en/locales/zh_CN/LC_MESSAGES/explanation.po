# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, holger krekel and pytest-dev team
# This file is distributed under the same license as the pytest package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pytest 7.1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-12 11:35+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../../en/explanation/anatomy.rst:4
msgid "Anatomy of a test"
msgstr "测试的解剖"

#: ../../../en/explanation/anatomy.rst:6
msgid ""
"In the simplest terms, a test is meant to look at the result of a "
"particular behavior, and make sure that result aligns with what you would"
" expect. Behavior is not something that can be empirically measured, "
"which is why writing tests can be challenging."
msgstr ""
"用最简单的话说，测试的目的是查看特定行为的结果，并确保结果与您所期望的一致。"
"行为是无法通过经验测量的，这就是为什么编写测试具有挑战性。"

#: ../../../en/explanation/anatomy.rst:11
msgid ""
"\"Behavior\" is the way in which some system **acts in response** to a "
"particular situation and/or stimuli. But exactly *how* or *why* something"
" is done is not quite as important as *what* was done."
msgstr ""
"\"Behavior\" 是一些系统对特定情况和/或刺激作出反应的方式。但“怎样”或“为什么”做某事并不像“做了什么”那么重要。"

#: ../../../en/explanation/anatomy.rst:15
msgid "You can think of a test as being broken down into four steps:"
msgstr "你可以把测试分为四个步骤："

#: ../../../en/explanation/anatomy.rst:17
msgid "**Arrange**"
msgstr ""

#: ../../../en/explanation/anatomy.rst:18
msgid "**Act**"
msgstr ""

#: ../../../en/explanation/anatomy.rst:19
msgid "**Assert**"
msgstr ""

#: ../../../en/explanation/anatomy.rst:20
msgid "**Cleanup**"
msgstr ""

#: ../../../en/explanation/anatomy.rst:22
msgid ""
"**Arrange** is where we prepare everything for our test. This means "
"pretty much everything except for the \"**act**\". It's lining up the "
"dominoes so that the **act** can do its thing in one, state-changing "
"step. This can mean preparing objects, starting/killing services, "
"entering records into a database, or even things like defining a URL to "
"query, generating some credentials for a user that doesn't exist yet, or "
"just waiting for some process to finish."
msgstr ""
"**Arrange** 是我们为考试准备一切的地方。这意味着除了 \"**act**\" 之外的几乎所有东西。"
"它是在排列多米诺骨牌，这样 **act** 就可以在一个改变状态的步骤中完成它的事情。"
"这可能意味着准备对象、启动/终止服务、将记录输入数据库，甚至定义要查询的 URL、为还不存在的用户生成一些凭证，或者只是等待某个进程完成。"

#: ../../../en/explanation/anatomy.rst:29
msgid ""
"**Act** is the singular, state-changing action that kicks off the "
"**behavior** we want to test. This behavior is what carries out the "
"changing of the state of the system under test (SUT), and it's the "
"resulting changed state that we can look at to make a judgement about the"
" behavior. This typically takes the form of a function/method call."
msgstr ""
"**Act** 是启动我们想要测试的 **behavior** 的单一的、改变状态的动作。"
"此行为执行了被测系统（system under test，简称 SUT）状态的更改，"
"我们可以通过查看更改后的状态来对该行为做出判断。这通常采用函数/方法调用的形式。"

#: ../../../en/explanation/anatomy.rst:35
msgid ""
"**Assert** is where we look at that resulting state and check if it looks"
" how we'd expect after the dust has settled. It's where we gather "
"evidence to say the behavior does or does not aligns with what we expect."
" The ``assert`` in our test is where we take that measurement/observation"
" and apply our judgement to it. If something should be green, we'd say "
"``assert thing == \"green\"``."
msgstr ""
"**Assert** 是我们查看结果状态的地方，并在尘埃落定后检查它是否像我们预期的那样。"
"这是我们收集证据的地方，表明行为是否符合我们的预期。”
“我们测试中的 ``assert`` 是我们进行测量/观察并应用我们的判断的地方。"
"如果某个东西应该是绿色的，我们会说 ``assert thing == \"green\"``。"

#: ../../../en/explanation/anatomy.rst:41
msgid ""
"**Cleanup** is where the test picks up after itself, so other tests "
"aren't being accidentally influenced by it."
msgstr ""
"**Cleanup** 是测试在自己之后进行清理，这样其他测试就不会意外地受到它的影响。"

#: ../../../en/explanation/anatomy.rst:44
msgid ""
"At its core, the test is ultimately the **act** and **assert** steps, "
"with the **arrange** step only providing the context. **Behavior** exists"
" between **act** and **assert**."
msgstr ""
"在其核心，测试最终是 **act** 和 **assert** 步骤，而 **arrange** 步骤只提供上下文。"
"**Behavior** 存在于 **act** 和 **assert** 之间。"

#: ../../../en/explanation/fixtures.rst:4
msgid "About fixtures"
msgstr "关于 fixtures"

#: ../../../en/explanation/fixtures.rst:6
msgid ":ref:`how-to-fixtures`"
msgstr ""

#: ../../../en/explanation/fixtures.rst:7
msgid ":ref:`Fixtures reference <reference-fixtures>`"
msgstr ""

#: ../../../en/explanation/fixtures.rst:9
msgid "pytest fixtures are designed to be explicit, modular and scalable."
msgstr "pytest fixture 被设计成显式的、模块化的和可扩展的。"

#: ../../../en/explanation/fixtures.rst:12
msgid "What fixtures are"
msgstr "fixtures 是什么"

#: ../../../en/explanation/fixtures.rst:14
msgid ""
"In testing, a `fixture "
"<https://en.wikipedia.org/wiki/Test_fixture#Software>`_ provides a "
"defined, reliable and consistent context for the tests. This could "
"include environment (for example a database configured with known "
"parameters) or content (such as a dataset)."
msgstr ""
"在测试中，`fixture <https://en.wikipedia.org/wiki/Test_fixture#Software>`_ 为测试提供一个定义的、可靠的和一致的上下文。"
"这可能包括环境(例如配置了已知参数的数据库)或内容(例如数据集)。"

#: ../../../en/explanation/fixtures.rst:19
msgid ""
"Fixtures define the steps and data that constitute the *arrange* phase of"
" a test (see :ref:`test-anatomy`). In pytest, they are functions you "
"define that serve this purpose. They can also be used to define a test's "
"*act* phase; this is a powerful technique for designing more complex "
"tests."
msgstr ""
"fixture定义了组成测试的 *arrange* 阶段的步骤和数据(参见 :ref:`test-anatomy`)。"

#: ../../../en/explanation/fixtures.rst:24
msgid ""
"The services, state, or other operating environments set up by fixtures "
"are accessed by test functions through arguments. For each fixture used "
"by a test function there is typically a parameter (named after the "
"fixture) in the test function's definition."
msgstr ""
"测试函数通过参数访问由 fixture 设置的服务、状态或其他操运算环境。"
"对于测试函数使用的每个 fixture，在测试函数的定义中通常都有一个参数(以 fixture 命名)。"

#: ../../../en/explanation/fixtures.rst:29
msgid ""
"We can tell pytest that a particular function is a fixture by decorating "
"it with :py:func:`@pytest.fixture <pytest.fixture>`. Here's a simple "
"example of what a fixture in pytest might look like:"
msgstr ""
"可以通过用 :py:func:`@pytest.fixture <pytest.fixture>` 装饰器来告诉 pytest 特定的函数是 fixture。"
"下面是简单的例子，说明 pytest 中的 fixture 可能是什么样子的："

#: ../../../en/explanation/fixtures.rst:59
msgid ""
"Tests don't have to be limited to a single fixture, either. They can "
"depend on as many fixtures as you want, and fixtures can use other "
"fixtures, as well. This is where pytest's fixture system really shines."
msgstr ""
"测试也不必局限于单一的 fixture。它们可以依赖于任意数量的 fixture，fixture 也可以使用其他 fixture。"
"这是 pytest 的 fixture 系统真正的亮点。"

#: ../../../en/explanation/fixtures.rst:65
msgid "Improvements over xUnit-style setup/teardown functions"
msgstr "对 xUnit 风格的 setup/teardown 函数的改进"

#: ../../../en/explanation/fixtures.rst:67
msgid ""
"pytest fixtures offer dramatic improvements over the classic xUnit style "
"of setup/teardown functions:"
msgstr ""
"pytest fixture 在经典的 xUnit 风格的 setup/teardown 函数上提供了显著的改进："

#: ../../../en/explanation/fixtures.rst:70
msgid ""
"fixtures have explicit names and are activated by declaring their use "
"from test functions, modules, classes or whole projects."
msgstr ""
"fixture 有显式名称，通过从测试函数、模块、类或整个项目中声明它们的使用来激活。"

#: ../../../en/explanation/fixtures.rst:73
msgid ""
"fixtures are implemented in a modular manner, as each fixture name "
"triggers a *fixture function* which can itself use other fixtures."
msgstr ""
"fixture 以模块化的方式实现，因为每个 fixture 名称触发一个 *fixture 函数*，该函数本身可以使用其他 fixture。"

#: ../../../en/explanation/fixtures.rst:76
msgid ""
"fixture management scales from simple unit to complex functional testing,"
" allowing to parametrize fixtures and tests according to configuration "
"and component options, or to re-use fixtures across function, class, "
"module or whole test session scopes."
msgstr ""
"fixture 管理从简单的单元扩展到复杂的功能测试，允许根据配置和组件选项对夹具和测试进行参数化，"
"或者跨函数、类、模块或整个测试会话范围重用 fixture。"

#: ../../../en/explanation/fixtures.rst:81
msgid ""
"teardown logic can be easily, and safely managed, no matter how many "
"fixtures are used, without the need to carefully handle errors by hand or"
" micromanage the order that cleanup steps are added."
msgstr ""
"无论使用了多少个 fixture，都可以轻松安全地管理 teardown 逻辑，而不需要手工小心地处理错误或微管理添加清理步骤的顺序。"

#: ../../../en/explanation/fixtures.rst:85
msgid ""
"In addition, pytest continues to support :ref:`xunitsetup`.  You can mix "
"both styles, moving incrementally from classic to new style, as you "
"prefer.  You can also start out from existing :ref:`unittest.TestCase "
"style <unittest.TestCase>` or :ref:`nose based <nosestyle>` projects."
msgstr ""
"此外，pytest 继续支持 :ref:`xunitsetup`。你可以混合这两种风格，根据你的喜好从经典风格逐渐过渡到新风格。"
"你也可以从现有的 :ref:`unittest.TestCase style <unittest.TestCase>` 或 :ref:`nose based <nosestyle>` 项目开始。"

#: ../../../en/explanation/fixtures.rst:93
msgid "Fixture errors"
msgstr "Fixture 错误"

#: ../../../en/explanation/fixtures.rst:95
msgid ""
"pytest does its best to put all the fixtures for a given test in a linear"
" order so that it can see which fixture happens first, second, third, and"
" so on. If an earlier fixture has a problem, though, and raises an "
"exception, pytest will stop executing fixtures for that test and mark the"
" test as having an error."
msgstr ""
"pytest 尽最大努力将给定测试的所有 fixture 按线性顺序排列，以便它可以看到哪个 fixture 发生在第一个、第二个、第三个，等等。"
"但是，如果早期的 fixture 有问题并引发异常，pytest 将停止执行该测试的 fixture，并将该测试标记为有错误。"

#: ../../../en/explanation/fixtures.rst:100
msgid ""
"When a test is marked as having an error, it doesn't mean the test "
"failed, though. It just means the test couldn't even be attempted because"
" one of the things it depends on had a problem."
msgstr ""
"当一个测试被标记为有错误时，并不意味着测试失败。这只是意味着测试甚至无法尝试，因为它所依赖的一个东西出了问题。"

#: ../../../en/explanation/fixtures.rst:104
msgid ""
"This is one reason why it's a good idea to cut out as many unnecessary "
"dependencies as possible for a given test. That way a problem in "
"something unrelated isn't causing us to have an incomplete picture of "
"what may or may not have issues."
msgstr ""
"这就是为什么在给定的测试中尽可能地减少不必要的依赖是一个好主意。"
"这样一来，不相关的问题就不会让我们对什么可能有问题或什么可能没有问题有不完整的认识。"

#: ../../../en/explanation/fixtures.rst:109
msgid "Here's a quick example to help explain:"
msgstr "这里有一个简单的例子来帮助解释："

#: ../../../en/explanation/fixtures.rst:140
msgid ""
"If, for whatever reason, ``order.append(1)`` had a bug and it raises an "
"exception, we wouldn't be able to know if ``order.extend([2])`` or "
"``order += [3]`` would also have problems. After ``append_first`` throws "
"an exception, pytest won't run any more fixtures for ``test_order``, and "
"it won't even try to run ``test_order`` itself. The only things that "
"would've run would be ``order`` and ``append_first``."
msgstr ""
"如果 ``order.append(1)`` 由于某种原因出现错误并引发异常，我们将无法知道 ``order.extend([2])`` 或 ``order += [3]`` 是否也有问题。"
"在 ``append_first`` 抛出异常之后，pytest 将不再为 ``test_order`` 运行任何 fixture，"
"它甚至不会尝试运行 ``test_order`` 本身。唯一会运行的是 ``order`` 和 ``append_first``。"

#: ../../../en/explanation/fixtures.rst:149
msgid "Sharing test data"
msgstr "共享测试数据"

#: ../../../en/explanation/fixtures.rst:151
msgid ""
"If you want to make test data from files available to your tests, a good "
"way to do this is by loading these data in a fixture for use by your "
"tests. This makes use of the automatic caching mechanisms of pytest."
msgstr ""
"如果您想让来自文件的测试数据对您的测试可用，一个好方法是将这些数据加载到 fixture 中供您的测试使用。"
"这利用了 pytest 的自动缓存机制。"

#: ../../../en/explanation/fixtures.rst:155
msgid ""
"Another good approach is by adding the data files in the ``tests`` "
"folder. There are also community plugins available to help to manage this"
" aspect of testing, e.g. :pypi:`pytest-datadir` and :pypi:`pytest-"
"datafiles`."
msgstr ""
"另一个好方法是在 ``tests`` 文件夹中添加数据文件。"
"还有一些社区插件可以帮助管理这方面的测试，例如 :pypi:`pytest-datadir` 和 :pypi:`pytest-datafiles`。"

#: ../../../en/explanation/fixtures.rst:162
msgid "A note about fixture cleanup"
msgstr "关于 fixture 清理的说明"

#: ../../../en/explanation/fixtures.rst:164
msgid ""
"pytest does not do any special processing for :data:`SIGTERM "
"<signal.SIGTERM>` and :data:`SIGQUIT <signal.SIGQUIT>` signals "
"(:data:`SIGINT <signal.SIGINT>` is handled naturally by the Python "
"runtime via :class:`KeyboardInterrupt`), so fixtures that manage external"
" resources which are important to be cleared when the Python process is "
"terminated (by those signals) might leak resources."
msgstr ""

#: ../../../en/explanation/fixtures.rst:169
msgid ""
"The reason pytest does not handle those signals to perform fixture "
"cleanup is that signal handlers are global, and changing them might "
"interfere with the code under execution."
msgstr ""

#: ../../../en/explanation/fixtures.rst:172
msgid ""
"If fixtures in your suite need special care regarding termination in "
"those scenarios, see :issue:`this comment <5243#issuecomment-491522595>` "
"in the issue tracker for a possible workaround."
msgstr ""

#: ../../../en/explanation/flaky.rst:3
msgid "Flaky tests"
msgstr ""

#: ../../../en/explanation/flaky.rst:5
msgid ""
"A \"flaky\" test is one that exhibits intermittent or sporadic failure, "
"that seems to have non-deterministic behaviour. Sometimes it passes, "
"sometimes it fails, and it's not clear why. This page discusses pytest "
"features that can help and other general strategies for identifying, "
"fixing or mitigating them."
msgstr ""

#: ../../../en/explanation/flaky.rst:8
msgid "Why flaky tests are a problem"
msgstr ""

#: ../../../en/explanation/flaky.rst:10
msgid ""
"Flaky tests are particularly troublesome when a continuous integration "
"(CI) server is being used, so that all tests must pass before a new code "
"change can be merged. If the test result is not a reliable signal -- that"
" a test failure means the code change broke the test -- developers can "
"become mistrustful of the test results, which can lead to overlooking "
"genuine failures. It is also a source of wasted time as developers must "
"re-run test suites and investigate spurious failures."
msgstr ""

#: ../../../en/explanation/flaky.rst:14
msgid "Potential root causes"
msgstr ""

#: ../../../en/explanation/flaky.rst:17
msgid "System state"
msgstr ""

#: ../../../en/explanation/flaky.rst:19
msgid ""
"Broadly speaking, a flaky test indicates that the test relies on some "
"system state that is not being appropriately controlled - the test "
"environment is not sufficiently isolated. Higher level tests are more "
"likely to be flaky as they rely on more state."
msgstr ""

#: ../../../en/explanation/flaky.rst:21
msgid ""
"Flaky tests sometimes appear when a test suite is run in parallel (such "
"as use of pytest-xdist). This can indicate a test is reliant on test "
"ordering."
msgstr ""

#: ../../../en/explanation/flaky.rst:23
msgid ""
"Perhaps a different test is failing to clean up after itself and leaving "
"behind data which causes the flaky test to fail."
msgstr ""

#: ../../../en/explanation/flaky.rst:24
msgid ""
"The flaky test is reliant on data from a previous test that doesn't clean"
" up after itself, and in parallel runs that previous test is not always "
"present"
msgstr ""

#: ../../../en/explanation/flaky.rst:25
msgid "Tests that modify global state typically cannot be run in parallel."
msgstr ""

#: ../../../en/explanation/flaky.rst:29
msgid "Overly strict assertion"
msgstr ""

#: ../../../en/explanation/flaky.rst:31
msgid ""
"Overly strict assertions can cause problems with floating point "
"comparison as well as timing issues. :func:`pytest.approx` is useful "
"here."
msgstr ""

#: ../../../en/explanation/flaky.rst:35
msgid "Pytest features"
msgstr ""

#: ../../../en/explanation/flaky.rst:38
msgid "Xfail strict"
msgstr ""

#: ../../../en/explanation/flaky.rst:40
msgid ""
":ref:`pytest.mark.xfail ref` with ``strict=False`` can be used to mark a "
"test so that its failure does not cause the whole build to break. This "
"could be considered like a manual quarantine, and is rather dangerous to "
"use permanently."
msgstr ""

#: ../../../en/explanation/flaky.rst:44
msgid "PYTEST_CURRENT_TEST"
msgstr ""

#: ../../../en/explanation/flaky.rst:46
msgid ""
":envvar:`PYTEST_CURRENT_TEST` may be useful for figuring out \"which test"
" got stuck\". See :ref:`pytest current test env` for more details."
msgstr ""

#: ../../../en/explanation/flaky.rst:51
msgid "Plugins"
msgstr ""

#: ../../../en/explanation/flaky.rst:53
msgid ""
"Rerunning any failed tests can mitigate the negative effects of flaky "
"tests by giving them additional chances to pass, so that the overall "
"build does not fail. Several pytest plugins support this:"
msgstr ""

#: ../../../en/explanation/flaky.rst:55
msgid "`flaky <https://github.com/box/flaky>`_"
msgstr ""

#: ../../../en/explanation/flaky.rst:56
msgid ""
"`pytest-flakefinder <https://github.com/dropbox/pytest-flakefinder>`_ - "
"`blog post <https://blogs.dropbox.com/tech/2016/03/open-sourcing-pytest-"
"tools/>`_"
msgstr ""

#: ../../../en/explanation/flaky.rst:57
msgid ""
"`pytest-rerunfailures <https://github.com/pytest-dev/pytest-"
"rerunfailures>`_"
msgstr ""

#: ../../../en/explanation/flaky.rst:58
msgid ""
"`pytest-replay <https://github.com/ESSS/pytest-replay>`_: This plugin "
"helps to reproduce locally crashes or flaky tests observed during CI "
"runs."
msgstr ""

#: ../../../en/explanation/flaky.rst:60
msgid ""
"Plugins to deliberately randomize tests can help expose tests with state "
"problems:"
msgstr ""

#: ../../../en/explanation/flaky.rst:62
msgid "`pytest-random-order <https://github.com/jbasko/pytest-random-order>`_"
msgstr ""

#: ../../../en/explanation/flaky.rst:63
msgid "`pytest-randomly <https://github.com/pytest-dev/pytest-randomly>`_"
msgstr ""

#: ../../../en/explanation/flaky.rst:67
msgid "Other general strategies"
msgstr ""

#: ../../../en/explanation/flaky.rst:70
msgid "Split up test suites"
msgstr ""

#: ../../../en/explanation/flaky.rst:72
msgid ""
"It can be common to split a single test suite into two, such as unit vs "
"integration, and only use the unit test suite as a CI gate. This also "
"helps keep build times manageable as high level tests tend to be slower. "
"However, it means it does become possible for code that breaks the build "
"to be merged, so extra vigilance is needed for monitoring the integration"
" test results."
msgstr ""

#: ../../../en/explanation/flaky.rst:76
msgid "Video/screenshot on failure"
msgstr ""

#: ../../../en/explanation/flaky.rst:78
msgid ""
"For UI tests these are important for understanding what the state of the "
"UI was when the test failed. pytest-splinter can be used with plugins "
"like pytest-bdd and can `save a screenshot on test failure <https"
"://pytest-splinter.readthedocs.io/en/latest/#automatic-screenshots-on-"
"test-failure>`_, which can help to isolate the cause."
msgstr ""

#: ../../../en/explanation/flaky.rst:82
msgid "Delete or rewrite the test"
msgstr ""

#: ../../../en/explanation/flaky.rst:84
msgid ""
"If the functionality is covered by other tests, perhaps the test can be "
"removed. If not, perhaps it can be rewritten at a lower level which will "
"remove the flakiness or make its source more apparent."
msgstr ""

#: ../../../en/explanation/flaky.rst:88
msgid "Quarantine"
msgstr ""

#: ../../../en/explanation/flaky.rst:90
msgid ""
"Mark Lapierre discusses the `Pros and Cons of Quarantined Tests "
"<https://dev.to/mlapierre/pros-and-cons-of-quarantined-tests-2emj>`_ in a"
" post from 2018."
msgstr ""

#: ../../../en/explanation/flaky.rst:95
msgid "CI tools that rerun on failure"
msgstr ""

#: ../../../en/explanation/flaky.rst:97
msgid ""
"Azure Pipelines (the Azure cloud CI/CD tool, formerly Visual Studio Team "
"Services or VSTS) has a feature to `identify flaky tests "
"<https://docs.microsoft.com/en-us/previous-"
"versions/azure/devops/2017/dec-11-vsts?view=tfs-2017#identify-flaky-"
"tests>`_ and rerun failed tests."
msgstr ""

#: ../../../en/explanation/flaky.rst:102
msgid "Research"
msgstr ""

#: ../../../en/explanation/flaky.rst:104
msgid ""
"This is a limited list, please submit an issue or pull request to expand "
"it!"
msgstr ""

#: ../../../en/explanation/flaky.rst:106
msgid ""
"Gao, Zebao, Yalan Liang, Myra B. Cohen, Atif M. Memon, and Zhen Wang. "
"\"Making system user interactive tests repeatable: When and what should "
"we control?.\" In *Software Engineering (ICSE), 2015 IEEE/ACM 37th IEEE "
"International Conference on*, vol. 1, pp. 55-65. IEEE, 2015.  `PDF "
"<http://www.cs.umd.edu/~atif/pubs/gao-icse15.pdf>`__"
msgstr ""

#: ../../../en/explanation/flaky.rst:107
msgid ""
"Palomba, Fabio, and Andy Zaidman. \"Does refactoring of test smells "
"induce fixing flaky tests?.\" In *Software Maintenance and Evolution "
"(ICSME), 2017 IEEE International Conference on*, pp. 1-12. IEEE, 2017. "
"`PDF in Google Drive <https://drive.google.com/file/d"
"/10HdcCQiuQVgW3yYUJD-TSTq1NbYEprl0/view>`__"
msgstr ""

#: ../../../en/explanation/flaky.rst:108
msgid ""
"Bell, Jonathan, Owolabi Legunsen, Michael Hilton, Lamyaa Eloussi, Tifany "
"Yung, and Darko Marinov. \"DeFlaker: Automatically detecting flaky "
"tests.\" In *Proceedings of the 2018 International Conference on Software"
" Engineering*. 2018. `PDF "
"<https://www.jonbell.net/icse18-deflaker.pdf>`__"
msgstr ""

#: ../../../en/explanation/flaky.rst:112
msgid "Resources"
msgstr ""

#: ../../../en/explanation/flaky.rst:114
msgid ""
"`Eradicating Non-Determinism in Tests "
"<https://martinfowler.com/articles/nonDeterminism.html>`_ by Martin "
"Fowler, 2011"
msgstr ""

#: ../../../en/explanation/flaky.rst:115
msgid ""
"`No more flaky tests on the Go team "
"<https://www.thoughtworks.com/insights/blog/no-more-flaky-tests-go-"
"team>`_ by Pavan Sudarshan, 2012"
msgstr ""

#: ../../../en/explanation/flaky.rst:116
msgid ""
"`The Build That Cried Broken: Building Trust in your Continuous "
"Integration Tests <https://www.youtube.com/embed/VotJqV4n8ig>`_ talk "
"(video) by `Angie Jones <https://angiejones.tech/>`_ at SeleniumConf "
"Austin 2017"
msgstr ""

#: ../../../en/explanation/flaky.rst:117
msgid ""
"`Test and Code Podcast: Flaky Tests and How to Deal with Them "
"<https://testandcode.com/50>`_ by Brian Okken and Anthony Shaw, 2018"
msgstr ""

#: ../../../en/explanation/flaky.rst:118
msgid "Microsoft:"
msgstr ""

#: ../../../en/explanation/flaky.rst:120
msgid ""
"`How we approach testing VSTS to enable continuous delivery "
"<https://blogs.msdn.microsoft.com/bharry/2017/06/28/testing-in-a-cloud-"
"delivery-cadence/>`_ by Brian Harry MS, 2017"
msgstr ""

#: ../../../en/explanation/flaky.rst:121
msgid ""
"`Eliminating Flaky Tests <https://docs.microsoft.com/en-"
"us/azure/devops/learn/devops-at-microsoft/eliminating-flaky-tests>`_ blog"
" and talk (video) by Munil Shah, 2017"
msgstr ""

#: ../../../en/explanation/flaky.rst:123
msgid "Google:"
msgstr ""

#: ../../../en/explanation/flaky.rst:125
msgid ""
"`Flaky Tests at Google and How We Mitigate Them "
"<https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-"
"we.html>`_ by John Micco, 2016"
msgstr ""

#: ../../../en/explanation/flaky.rst:126
msgid ""
"`Where do Google's flaky tests come from? "
"<https://testing.googleblog.com/2017/04/where-do-our-flaky-tests-come-"
"from.html>`_  by Jeff Listfield, 2017"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:5
msgid "Good Integration Practices"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:8
msgid "Install package with pip"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:10
msgid ""
"For development, we recommend you use :mod:`venv` for virtual "
"environments and :doc:`pip:index` for installing your application and any"
" dependencies, as well as the ``pytest`` package itself. This ensures "
"your code and dependencies are isolated from your system Python "
"installation."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:15
msgid ""
"Create a ``pyproject.toml`` file in the root of your repository as "
"described in :doc:`packaging:tutorials/packaging-projects`. The first few"
" lines should look like this:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:28
msgid "where ``PACKAGENAME`` is the name of your package."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:30
msgid ""
"You can then install your package in \"editable\" mode by running from "
"the same directory:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:36
msgid ""
"which lets you change your source code (both tests and application) and "
"rerun tests at will."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:42
msgid "Conventions for Python test discovery"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:44
msgid "``pytest`` implements the following standard test discovery:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:46
msgid ""
"If no arguments are specified then collection starts from "
":confval:`testpaths` (if configured) or the current directory. "
"Alternatively, command line arguments can be used in any combination of "
"directories, file names or node ids."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:49
msgid "Recurse into directories, unless they match :confval:`norecursedirs`."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:50
msgid ""
"In those directories, search for ``test_*.py`` or ``*_test.py`` files, "
"imported by their `test package name`_."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:51
msgid "From those files, collect test items:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:53
msgid "``test`` prefixed test functions or methods outside of class"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:54
msgid ""
"``test`` prefixed test functions or methods inside ``Test`` prefixed test"
" classes (without an ``__init__`` method)"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:56
msgid ""
"For examples of how to customize your test discovery "
":doc:`/example/pythoncollection`."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:58
msgid ""
"Within Python modules, ``pytest`` also discovers tests using the standard"
" :ref:`unittest.TestCase <unittest.TestCase>` subclassing technique."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:63
msgid "Choosing a test layout / import rules"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:65
msgid "``pytest`` supports two common test layouts:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:68
msgid "Tests outside application code"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:70
msgid ""
"Putting tests into an extra directory outside your actual application "
"code might be useful if you have many functional tests or for other "
"reasons want to keep tests separate from actual application code (often a"
" good idea):"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:87
msgid "This has the following benefits:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:89
msgid ""
"Your tests can run against an installed version after executing ``pip "
"install .``."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:90
msgid ""
"Your tests can run against the local copy with an editable install after "
"executing ``pip install --editable .``."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:92
msgid ""
"For new projects, we recommend to use ``importlib`` :ref:`import mode "
"<import-modes>` (see which-import-mode_ for a detailed explanation). To "
"this end, add the following to your ``pyproject.toml``:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:105
msgid ""
"Generally, but especially if you use the default import mode ``prepend``,"
" it is **strongly** suggested to use a ``src`` layout. Here, your "
"application root package resides in a sub-directory of your root, i.e. "
"``src/mypkg/`` instead of ``mypkg``."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:110
msgid ""
"This layout prevents a lot of common pitfalls and has many benefits, "
"which are better explained in this excellent `blog post`_ by Ionel "
"Cristian Mărieș."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:117
msgid ""
"If you do not use an editable install and use the ``src`` layout as above"
" you need to extend the Python's search path for module files to execute "
"the tests against the local copy directly. You can do it in an ad-hoc "
"manner by setting the ``PYTHONPATH`` environment variable:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:125
msgid ""
"or in a permanent manner by using the :confval:`pythonpath` configuration"
" variable and adding the following to your ``pyproject.toml``:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:135
msgid ""
"If you do not use an editable install and not use the ``src`` layout "
"(``mypkg`` directly in the root directory) you can rely on the fact that "
"Python by default puts the current directory in ``sys.path`` to import "
"your package and run ``python -m pytest`` to execute the tests against "
"the local copy directly."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:139
msgid ""
"See :ref:`pytest vs python -m pytest` for more information about the "
"difference between calling ``pytest`` and ``python -m pytest``."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:143
msgid "Tests as part of application code"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:145
msgid ""
"Inlining test directories into your application package is useful if you "
"have direct relation between tests and application modules and want to "
"distribute them along with your application:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:162
msgid ""
"In this scheme, it is easy to run your tests using the ``--pyargs`` "
"option:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:168
msgid ""
"``pytest`` will discover where ``mypkg`` is installed and collect tests "
"from there."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:170
msgid ""
"Note that this layout also works in conjunction with the ``src`` layout "
"mentioned in the previous section."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:175
msgid ""
"You can use namespace packages (PEP420) for your application but pytest "
"will still perform `test package name`_ discovery based on the presence "
"of ``__init__.py`` files.  If you use one of the two recommended file "
"system layouts above but leave away the ``__init__.py`` files from your "
"directories, it should just work.  From \"inlined tests\", however, you "
"will need to use absolute imports for getting at your application code."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:187
msgid ""
"In ``prepend`` and ``append`` import-modes, if pytest finds a "
"``\"a/b/test_module.py\"`` test file while recursing into the filesystem "
"it determines the import name as follows:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:191
msgid ""
"determine ``basedir``: this is the first \"upward\" (towards the root) "
"directory not containing an ``__init__.py``.  If e.g. both ``a`` and "
"``b`` contain an ``__init__.py`` file then the parent directory of ``a`` "
"will become the ``basedir``."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:196
msgid ""
"perform ``sys.path.insert(0, basedir)`` to make the test module "
"importable under the fully qualified import name."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:199
msgid ""
"``import a.b.test_module`` where the path is determined by converting "
"path separators ``/`` into \".\" characters.  This means you must follow "
"the convention of having directory and file names map directly to the "
"import names."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:204
msgid ""
"The reason for this somewhat evolved importing technique is that in "
"larger projects multiple test modules might import from each other and "
"thus deriving a canonical import name helps to avoid surprises such as a "
"test module getting imported twice."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:209
msgid ""
"With ``--import-mode=importlib`` things are less convoluted because "
"pytest doesn't need to change ``sys.path`` or ``sys.modules``, making "
"things much less surprising."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:217
msgid "Choosing an import mode"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:219
msgid ""
"For historical reasons, pytest defaults to the ``prepend`` :ref:`import "
"mode <import-modes>` instead of the ``importlib`` import mode we "
"recommend for new projects. The reason lies in the way the ``prepend`` "
"mode works:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:223
msgid ""
"Since there are no packages to derive a full package name from, "
"``pytest`` will import your test files as *top-level* modules. The test "
"files in the first example (:ref:`src layout <src-layout>`) would be "
"imported as ``test_app`` and ``test_view`` top-level modules by adding "
"``tests/`` to ``sys.path``."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:228
msgid ""
"This results in a drawback compared to the import mode ``importlib``: "
"your test files must have **unique names**."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:231
msgid ""
"If you need to have test modules with the same name, as a workaround you "
"might add ``__init__.py`` files to your ``tests`` folder and subfolders, "
"changing them to packages:"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:249
msgid ""
"Now pytest will load the modules as ``tests.foo.test_view`` and "
"``tests.bar.test_view``, allowing you to have modules with the same name."
" But now this introduces a subtle problem: in order to load the test "
"modules from the ``tests`` directory, pytest prepends the root of the "
"repository to ``sys.path``, which adds the side-effect that now ``mypkg``"
" is also importable."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:256
msgid ""
"This is problematic if you are using a tool like tox_ to test your "
"package in a virtual environment, because you want to test the "
"*installed* version of your package, not the local code from the "
"repository."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:260
msgid ""
"The ``importlib`` import mode does not have any of the drawbacks above, "
"because ``sys.path`` is not changed when importing test modules."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:269
msgid "tox"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:271
msgid ""
"Once you are done with your work and want to make sure that your actual "
"package passes all tests you may want to look into :doc:`tox "
"<tox:index>`, the virtualenv test automation tool and its :doc:`pytest "
"support <tox:example/pytest>`. tox helps you to setup virtualenv "
"environments with pre-defined dependencies and then executing a pre-"
"configured test command with options.  It will run tests against the "
"installed package and not against your source code checkout, helping to "
"detect packaging glitches."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:281
msgid "Do not run via setuptools"
msgstr ""

#: ../../../en/explanation/goodpractices.rst:283
msgid ""
"Integration with setuptools is **not recommended**, i.e. you should not "
"be using ``python setup.py test`` or ``pytest-runner``, and may stop "
"working in the future."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:287
msgid ""
"This is deprecated since it depends on deprecated features of setuptools "
"and relies on features that break security mechanisms in pip. For example"
" 'setup_requires' and 'tests_require' bypass ``pip --require-hashes``. "
"For more information and migration instructions, see the `pytest-runner "
"notice <https://github.com/pytest-dev/pytest-runner#deprecation-"
"notice>`_. See also `pypa/setuptools#1684 "
"<https://github.com/pypa/setuptools/issues/1684>`_."
msgstr ""

#: ../../../en/explanation/goodpractices.rst:294
msgid ""
"setuptools intends to `remove the test command "
"<https://github.com/pypa/setuptools/issues/931>`_."
msgstr ""

#: ../../../en/explanation/index.rst:6
msgid "Explanation"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:4
msgid "pytest import mechanisms and ``sys.path``/``PYTHONPATH``"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:9
msgid "Import modes"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:11
msgid ""
"pytest as a testing framework needs to import test modules and "
"``conftest.py`` files for execution."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:13
msgid ""
"Importing files in Python (at least until recently) is a non-trivial "
"processes, often requiring changing :data:`sys.path`. Some aspects of the"
" import process can be controlled through the ``--import-mode`` command-"
"line flag, which can assume these values:"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:18
msgid ""
"``prepend`` (default): the directory path containing each module will be "
"inserted into the *beginning* of :py:data:`sys.path` if not already "
"there, and then imported with the :func:`__import__ <__import__>` "
"builtin."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:21
msgid ""
"This requires test module names to be unique when the test directory tree"
" is not arranged in packages, because the modules will put in "
":py:data:`sys.modules` after importing."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:24
msgid ""
"This is the classic mechanism, dating back from the time Python 2 was "
"still supported."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:26
msgid ""
"``append``: the directory containing each module is appended to the end "
"of :py:data:`sys.path` if not already there, and imported with "
"``__import__``."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:29
msgid ""
"This better allows to run test modules against installed versions of a "
"package even if the package under test has the same import root. For "
"example:"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:38
msgid ""
"the tests will run against the installed version of ``pkg_under_test`` "
"when ``--import-mode=append`` is used whereas with ``prepend`` they would"
" pick up the local version. This kind of confusion is why we advocate for"
" using :ref:`src <src-layout>` layouts."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:43
msgid ""
"Same as ``prepend``, requires test module names to be unique when the "
"test directory tree is not arranged in packages, because the modules will"
" put in :py:data:`sys.modules` after importing."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:46
msgid ""
"``importlib``: new in pytest-6.0, this mode uses :mod:`importlib` to "
"import test modules. This gives full control over the import process, and"
" doesn't require changing :py:data:`sys.path`."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:48
msgid "For this reason this doesn't require test module names to be unique."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:50
msgid ""
"One drawback however is that test modules are non-importable by each "
"other. Also,  utility modules in the tests directories are not "
"automatically importable because the tests directory is no longer added "
"to :py:data:`sys.path`."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:54
msgid ""
"Initially we intended to make ``importlib`` the default in future "
"releases, however it is clear now that it has its own set of drawbacks so"
" the default will remain ``prepend`` for the foreseeable future."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:59
msgid "The :confval:`pythonpath` configuration variable."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:63
msgid "``prepend`` and ``append`` import modes scenarios"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:65
msgid ""
"Here's a list of scenarios when using ``prepend`` or ``append`` import "
"modes where pytest needs to change ``sys.path`` in order to import test "
"modules or ``conftest.py`` files, and the issues users might encounter "
"because of that."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:70
msgid "Test modules / ``conftest.py`` files inside packages"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:72
#: ../../../en/explanation/pythonpath.rst:107
msgid "Consider this file and directory layout::"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:85
#: ../../../en/explanation/pythonpath.rst:117
msgid "When executing:"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:91
msgid ""
"pytest will find ``foo/bar/tests/test_foo.py`` and realize it is part of "
"a package given that there's an ``__init__.py`` file in the same folder. "
"It will then search upwards until it can find the last folder which still"
" contains an ``__init__.py`` file in order to find the package *root* (in"
" this case ``foo/``). To load the module, it will insert ``root/``  to "
"the front of ``sys.path`` (if not there already) in order to load "
"``test_foo.py`` as the *module* ``foo.bar.tests.test_foo``."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:98
msgid ""
"The same logic applies to the ``conftest.py`` file: it will be imported "
"as ``foo.conftest`` module."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:100
msgid ""
"Preserving the full package name is important when tests live in a "
"package to avoid problems and allow test modules to have duplicated "
"names. This is also discussed in details in :ref:`test discovery`."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:105
msgid "Standalone test modules / ``conftest.py`` files"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:123
msgid ""
"pytest will find ``foo/bar/tests/test_foo.py`` and realize it is NOT part"
" of a package given that there's no ``__init__.py`` file in the same "
"folder. It will then add ``root/foo/bar/tests`` to ``sys.path`` in order "
"to import ``test_foo.py`` as the *module* ``test_foo``. The same is done "
"with the ``conftest.py`` file by adding ``root/foo`` to ``sys.path`` to "
"import it as ``conftest``."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:128
msgid ""
"For this reason this layout cannot have test modules with the same name, "
"as they all will be imported in the global import namespace."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:131
msgid "This is also discussed in details in :ref:`test discovery`."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:136
msgid "Invoking ``pytest`` versus ``python -m pytest``"
msgstr ""

#: ../../../en/explanation/pythonpath.rst:138
msgid ""
"Running pytest with ``pytest [...]`` instead of ``python -m pytest "
"[...]`` yields nearly equivalent behaviour, except that the latter will "
"add the current directory to ``sys.path``, which is standard ``python`` "
"behavior."
msgstr ""

#: ../../../en/explanation/pythonpath.rst:142
msgid "See also :ref:`invoke-python`."
msgstr ""

