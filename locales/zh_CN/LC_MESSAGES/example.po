# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, holger krekel and pytest-dev team
# This file is distributed under the same license as the pytest package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pytest 7.1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-12 11:35+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../../en/example/index.rst:5
msgid "Examples and customization tricks"
msgstr ""

#: ../../../en/example/index.rst:7
msgid ""
"Here is a (growing) list of examples. :ref:`Contact <contact>` us if you "
"need more examples or have questions. Also take a look at the "
":ref:`comprehensive documentation <toc>` which contains many example "
"snippets as well.  Also, `pytest on stackoverflow.com "
"<http://stackoverflow.com/search?q=pytest>`_ often comes with example "
"answers."
msgstr ""

#: ../../../en/example/index.rst:14
msgid "For basic examples, see"
msgstr ""

#: ../../../en/example/index.rst:16
msgid ":ref:`get-started` for basic introductory examples"
msgstr ""

#: ../../../en/example/index.rst:17
msgid ":ref:`assert` for basic assertion examples"
msgstr ""

#: ../../../en/example/index.rst:18
msgid ":ref:`Fixtures <fixtures>` for basic fixture/setup examples"
msgstr ""

#: ../../../en/example/index.rst:19
msgid ":ref:`parametrize` for basic test function parametrization"
msgstr ""

#: ../../../en/example/index.rst:20
msgid ":ref:`unittest` for basic unittest integration"
msgstr ""

#: ../../../en/example/index.rst:21
msgid ":ref:`noseintegration` for basic nosetests integration"
msgstr ""

#: ../../../en/example/index.rst:23
msgid "The following examples aim at various use cases you might encounter."
msgstr ""

#: ../../../en/example/markers.rst:5
msgid "Working with custom markers"
msgstr ""

#: ../../../en/example/markers.rst:7
msgid "Here are some examples using the :ref:`mark` mechanism."
msgstr ""

#: ../../../en/example/markers.rst:12
msgid "Marking test functions and selecting them for a run"
msgstr ""

#: ../../../en/example/markers.rst:14
msgid "You can \"mark\" a test function with custom metadata like this:"
msgstr ""

#: ../../../en/example/markers.rst:42
msgid ""
"You can then restrict a test run to only run tests marked with "
"``webtest``:"
msgstr ""

#: ../../../en/example/markers.rst:57
msgid "Or the inverse, running all tests except the webtest ones:"
msgstr ""

#: ../../../en/example/markers.rst:75
msgid "Selecting tests based on their node ID"
msgstr ""

#: ../../../en/example/markers.rst:77
msgid ""
"You can provide one or more :ref:`node IDs <node-id>` as positional "
"arguments to select only specified tests. This makes it easy to select "
"tests based on their module, class, method, or function name:"
msgstr ""

#: ../../../en/example/markers.rst:94
msgid "You can also select on the class:"
msgstr ""

#: ../../../en/example/markers.rst:109
msgid "Or select multiple nodes:"
msgstr ""

#: ../../../en/example/markers.rst:129
msgid ""
"Node IDs are of the form ``module.py::class::method`` or "
"``module.py::function``.  Node IDs control which tests are collected, so "
"``module.py::class`` will select all test methods on the class.  Nodes "
"are also created for each parameter of a parametrized fixture or test, so"
" selecting a parametrized test must include the parameter value, e.g. "
"``module.py::function[param]``."
msgstr ""

#: ../../../en/example/markers.rst:137
msgid ""
"Node IDs for failing tests are displayed in the test summary info when "
"running pytest with the ``-rf`` option.  You can also construct Node IDs "
"from the output of ``pytest --collectonly``."
msgstr ""

#: ../../../en/example/markers.rst:142
msgid "Using ``-k expr`` to select tests based on their name"
msgstr ""

#: ../../../en/example/markers.rst:146
msgid ""
"You can use the ``-k`` command line option to specify an expression which"
" implements a substring match on the test names instead of the exact "
"match on markers that ``-m`` provides.  This makes it easy to select "
"tests based on their names:"
msgstr ""

#: ../../../en/example/markers.rst:153
msgid "The expression matching is now case-insensitive."
msgstr ""

#: ../../../en/example/markers.rst:168
msgid "And you can also run all tests except the ones that match the keyword:"
msgstr ""

#: ../../../en/example/markers.rst:185
msgid "Or to select \"http\" and \"quick\" tests:"
msgstr ""

#: ../../../en/example/markers.rst:201
msgid "You can use ``and``, ``or``, ``not`` and parentheses."
msgstr ""

#: ../../../en/example/markers.rst:204
msgid ""
"In addition to the test's name, ``-k`` also matches the names of the "
"test's parents (usually, the name of the file and class it's in), "
"attributes set on the test function, markers applied to it or its parents"
" and any :attr:`extra keywords "
"<_pytest.nodes.Node.extra_keyword_matches>` explicitly added to it or its"
" parents."
msgstr ""

#: ../../../en/example/markers.rst:210
msgid "Registering markers"
msgstr ""

#: ../../../en/example/markers.rst:216
msgid "Registering markers for your test suite is simple:"
msgstr ""

#: ../../../en/example/markers.rst:226
msgid ""
"Multiple custom markers can be registered, by defining each one in its "
"own line, as shown in above example."
msgstr ""

#: ../../../en/example/markers.rst:228
msgid ""
"You can ask which markers exist for your test suite - the list includes "
"our just defined ``webtest`` and ``slow`` markers:"
msgstr ""

#: ../../../en/example/markers.rst:254
msgid ""
"For an example on how to add and work with markers from a plugin, see "
":ref:`adding a custom marker from a plugin`."
msgstr ""

#: ../../../en/example/markers.rst:259
msgid "It is recommended to explicitly register markers so that:"
msgstr ""

#: ../../../en/example/markers.rst:261
msgid "There is one place in your test suite defining your markers"
msgstr ""

#: ../../../en/example/markers.rst:263
msgid "Asking for existing markers via ``pytest --markers`` gives good output"
msgstr ""

#: ../../../en/example/markers.rst:265
msgid ""
"Typos in function markers are treated as an error if you use the "
"``--strict-markers`` option."
msgstr ""

#: ../../../en/example/markers.rst:271
msgid "Marking whole classes or modules"
msgstr ""

#: ../../../en/example/markers.rst:273
msgid ""
"You may use ``pytest.mark`` decorators with classes to apply markers to "
"all of its test methods:"
msgstr ""

#: ../../../en/example/markers.rst:290
msgid ""
"This is equivalent to directly applying the decorator to the two test "
"functions."
msgstr ""

#: ../../../en/example/markers.rst:293
msgid ""
"To apply marks at the module level, use the :globalvar:`pytestmark` "
"global variable::"
msgstr ""

#: ../../../en/example/markers.rst:298
msgid "or multiple markers::"
msgstr ""

#: ../../../en/example/markers.rst:303
msgid ""
"Due to legacy reasons, before class decorators were introduced, it is "
"possible to set the :globalvar:`pytestmark` attribute on a test class "
"like this:"
msgstr ""

#: ../../../en/example/markers.rst:317
msgid "Marking individual tests when using parametrize"
msgstr ""

#: ../../../en/example/markers.rst:319
msgid ""
"When using parametrize, applying a mark will make it apply to each "
"individual test. However it is also possible to apply a marker to an "
"individual test instance:"
msgstr ""

#: ../../../en/example/markers.rst:335
msgid ""
"In this example the mark \"foo\" will apply to each of the three tests, "
"whereas the \"bar\" mark is only applied to the second test. Skip and "
"xfail marks can also be applied in this way, see :ref:`skip/xfail with "
"parametrize`."
msgstr ""

#: ../../../en/example/markers.rst:342
msgid "Custom marker and command line option to control test runs"
msgstr ""

#: ../../../en/example/markers.rst:346
msgid ""
"Plugins can provide custom markers and implement specific behaviour based"
" on it. This is a self-contained example which adds a command line option"
" and a parametrized test function marker to run tests specified via named"
" environments:"
msgstr ""

#: ../../../en/example/markers.rst:380
msgid "A test file using this local plugin:"
msgstr ""

#: ../../../en/example/markers.rst:393
msgid ""
"and an example invocations specifying a different environment than what "
"the test needs:"
msgstr ""

#: ../../../en/example/markers.rst:408
msgid "and here is one that specifies exactly the environment needed:"
msgstr ""

#: ../../../en/example/markers.rst:422
msgid "The ``--markers`` option always gives you a list of available markers:"
msgstr ""

#: ../../../en/example/markers.rst:449
msgid "Passing a callable to custom markers"
msgstr ""

#: ../../../en/example/markers.rst:453
msgid "Below is the config file that will be used in the next examples:"
msgstr ""

#: ../../../en/example/markers.rst:466
msgid ""
"A custom marker can have its argument set, i.e. ``args`` and ``kwargs`` "
"properties, defined by either invoking it as a callable or using "
"``pytest.mark.MARKER_NAME.with_args``. These two methods achieve the same"
" effect most of the time."
msgstr ""

#: ../../../en/example/markers.rst:468
msgid ""
"However, if there is a callable as the single positional argument with no"
" keyword arguments, using the ``pytest.mark.MARKER_NAME(c)`` will not "
"pass ``c`` as a positional argument but decorate ``c`` with the custom "
"marker (see :ref:`MarkDecorator <mark>`). Fortunately, "
"``pytest.mark.MARKER_NAME.with_args`` comes to the rescue:"
msgstr ""

#: ../../../en/example/markers.rst:484
msgid "The output is as follows:"
msgstr ""

#: ../../../en/example/markers.rst:493
msgid ""
"We can see that the custom marker has its argument set extended with the "
"function ``hello_world``. This is the key difference between creating a "
"custom marker as a callable, which invokes ``__call__`` behind the "
"scenes, and using ``with_args``."
msgstr ""

#: ../../../en/example/markers.rst:497
msgid "Reading markers which were set from multiple places"
msgstr ""

#: ../../../en/example/markers.rst:503
msgid ""
"If you are heavily using markers in your test suite you may encounter the"
" case where a marker is applied several times to a test function.  From "
"plugin code you can read over all such settings.  Example:"
msgstr ""

#: ../../../en/example/markers.rst:520
msgid ""
"Here we have the marker \"glob\" applied three times to the same test "
"function.  From a conftest file we can read it like this:"
msgstr ""

#: ../../../en/example/markers.rst:534
msgid "Let's run this without capturing output and see what we get:"
msgstr ""

#: ../../../en/example/markers.rst:546
msgid "Marking platform specific tests with pytest"
msgstr ""

#: ../../../en/example/markers.rst:550
msgid ""
"Consider you have a test suite which marks tests for particular "
"platforms, namely ``pytest.mark.darwin``, ``pytest.mark.win32`` etc. and "
"you also have tests that run on all platforms and have no specific "
"marker.  If you now want to have a way to only run the tests for your "
"particular platform, you could use the following plugin:"
msgstr ""

#: ../../../en/example/markers.rst:573
msgid ""
"then tests will be skipped if they were specified for a different "
"platform. Let's do a little test file to show how this looks like:"
msgstr ""

#: ../../../en/example/markers.rst:601
msgid "then you will see two tests skipped and two executed tests as expected:"
msgstr ""

#: ../../../en/example/markers.rst:617
msgid ""
"Note that if you specify a platform via the marker-command line option "
"like this:"
msgstr ""

#: ../../../en/example/markers.rst:631
msgid ""
"then the unmarked-tests will not be run.  It is thus a way to restrict "
"the run to the specific tests."
msgstr ""

#: ../../../en/example/markers.rst:634
msgid "Automatically adding markers based on test names"
msgstr ""

#: ../../../en/example/markers.rst:638
msgid ""
"If you have a test suite where test function names indicate a certain "
"type of test, you can implement a hook that automatically defines markers"
" so that you can use the ``-m`` option with it. Let's look at this test "
"module:"
msgstr ""

#: ../../../en/example/markers.rst:663
msgid ""
"We want to dynamically define two markers and can do it in a "
"``conftest.py`` plugin:"
msgstr ""

#: ../../../en/example/markers.rst:680
msgid "We can now use the ``-m option`` to select one set:"
msgstr ""

#: ../../../en/example/markers.rst:706
msgid "or to select both \"event\" and \"interface\" tests:"
msgstr ""

#: ../../../en/example/nonpython.rst:5
msgid "Working with non-python tests"
msgstr ""

#: ../../../en/example/nonpython.rst:10
msgid "A basic example for specifying tests in Yaml files"
msgstr ""

#: ../../../en/example/nonpython.rst:14
msgid ""
"Here is an example ``conftest.py`` (extracted from Ali Afshar's special "
"purpose `pytest-yamlwsgi`_ plugin).   This ``conftest.py`` will  collect "
"``test*.yaml`` files and will execute the yaml-formatted content as "
"custom tests:"
msgstr ""

#: ../../../en/example/nonpython.rst:19
msgid "You can create a simple example file:"
msgstr ""

#: ../../../en/example/nonpython.rst:24
msgid ""
"and if you installed :pypi:`PyYAML` or a compatible YAML-parser you can "
"now execute the test specification:"
msgstr ""

#: ../../../en/example/nonpython.rst:48
msgid ""
"You get one dot for the passing ``sub1: sub1`` check and one failure. "
"Obviously in the above ``conftest.py`` you'll want to implement a more "
"interesting interpretation of the yaml-values.  You can easily write your"
" own domain specific testing language this way."
msgstr ""

#: ../../../en/example/nonpython.rst:55
msgid ""
"``repr_failure(excinfo)`` is called for representing test failures. If "
"you create custom collection nodes you can return an error representation"
" string of your choice.  It will be reported as a (red) string."
msgstr ""

#: ../../../en/example/nonpython.rst:60
msgid ""
"``reportinfo()`` is used for representing the test location and is also "
"consulted when reporting in ``verbose`` mode:"
msgstr ""

#: ../../../en/example/nonpython.rst:86
msgid ""
"While developing your custom test collection and execution it's also "
"interesting to just look at the collection tree:"
msgstr ""

#: ../../../en/example/parametrize.rst:5
msgid "Parametrizing tests"
msgstr ""

#: ../../../en/example/parametrize.rst:9
msgid ""
"``pytest`` allows to easily parametrize test functions. For basic docs, "
"see :ref:`parametrize-basics`."
msgstr ""

#: ../../../en/example/parametrize.rst:12
msgid "In the following we provide some examples using the builtin mechanisms."
msgstr ""

#: ../../../en/example/parametrize.rst:16
msgid "Generating parameters combinations, depending on command line"
msgstr ""

#: ../../../en/example/parametrize.rst:20
msgid ""
"Let's say we want to execute a test with different computation parameters"
" and the parameter range shall be determined by a command line argument."
"  Let's first write a simple (do-nothing) computation test:"
msgstr ""

#: ../../../en/example/parametrize.rst:32
msgid "Now we add a test configuration like this:"
msgstr ""

#: ../../../en/example/parametrize.rst:51
msgid "This means that we only run 2 tests if we do not pass ``--all``:"
msgstr ""

#: ../../../en/example/parametrize.rst:59
msgid ""
"We run only two computations, so we see two dots. let's run the full "
"monty:"
msgstr ""

#: ../../../en/example/parametrize.rst:80
msgid ""
"As expected when running the full range of ``param1`` values we'll get an"
" error on the last one."
msgstr ""

#: ../../../en/example/parametrize.rst:85
msgid "Different options for test IDs"
msgstr ""

#: ../../../en/example/parametrize.rst:87
msgid ""
"pytest will build a string that is the test ID for each set of values in "
"a parametrized test. These IDs can be used with ``-k`` to select specific"
" cases to run, and they will also identify the specific case when one is "
"failing. Running pytest with ``--collect-only`` will show the generated "
"IDs."
msgstr ""

#: ../../../en/example/parametrize.rst:92
msgid ""
"Numbers, strings, booleans and None will have their usual string "
"representation used in the test ID. For other objects, pytest will make a"
" string based on the argument name:"
msgstr ""

#: ../../../en/example/parametrize.rst:149
msgid "In ``test_timedistance_v0``, we let pytest generate the test IDs."
msgstr ""

#: ../../../en/example/parametrize.rst:151
msgid ""
"In ``test_timedistance_v1``, we specified ``ids`` as a list of strings "
"which were used as the test IDs. These are succinct, but can be a pain to"
" maintain."
msgstr ""

#: ../../../en/example/parametrize.rst:154
msgid ""
"In ``test_timedistance_v2``, we specified ``ids`` as a function that can "
"generate a string representation to make part of the test ID. So our "
"``datetime`` values use the label generated by ``idfn``, but because we "
"didn't generate a label for ``timedelta`` objects, they are still using "
"the default pytest representation:"
msgstr ""

#: ../../../en/example/parametrize.rst:179
msgid ""
"In ``test_timedistance_v3``, we used ``pytest.param`` to specify the test"
" IDs together with the actual data, instead of listing them separately."
msgstr ""

#: ../../../en/example/parametrize.rst:183
msgid "A quick port of \"testscenarios\""
msgstr ""

#: ../../../en/example/parametrize.rst:185
msgid ""
"Here is a quick port to run tests configured with :pypi:`testscenarios`, "
"an add-on from Robert Collins for the standard unittest framework. We "
"only have to work a bit to construct the correct arguments for pytest's "
":py:func:`Metafunc.parametrize`:"
msgstr ""

#: ../../../en/example/parametrize.rst:219
msgid "this is a fully self-contained example which you can run with:"
msgstr ""

#: ../../../en/example/parametrize.rst:233
msgid ""
"If you just collect tests you'll also nicely see 'advanced' and 'basic' "
"as variants for the test function:"
msgstr ""

#: ../../../en/example/parametrize.rst:252
msgid ""
"Note that we told ``metafunc.parametrize()`` that your scenario values "
"should be considered class-scoped.  With pytest-2.3 this leads to a "
"resource-based ordering."
msgstr ""

#: ../../../en/example/parametrize.rst:257
msgid "Deferring the setup of parametrized resources"
msgstr ""

#: ../../../en/example/parametrize.rst:261
msgid ""
"The parametrization of test functions happens at collection time.  It is "
"a good idea to setup expensive resources like DB connections or "
"subprocess only when the actual test is run. Here is a simple example how"
" you can achieve that. This test requires a ``db`` object fixture:"
msgstr ""

#: ../../../en/example/parametrize.rst:279
msgid ""
"We can now add a test configuration that generates two invocations of the"
" ``test_db_initialized`` function and also implements a factory that "
"creates a database object for the actual test invocations:"
msgstr ""

#: ../../../en/example/parametrize.rst:311
msgid "Let's first see how it looks like at collection time:"
msgstr ""

#: ../../../en/example/parametrize.rst:327
msgid "And then when we run the test:"
msgstr ""

#: ../../../en/example/parametrize.rst:349
msgid ""
"The first invocation with ``db == \"DB1\"`` passed while the second with "
"``db == \"DB2\"`` failed.  Our ``db`` fixture function has instantiated "
"each of the DB values during the setup phase while the "
"``pytest_generate_tests`` generated two according calls to the "
"``test_db_initialized`` during the collection phase."
msgstr ""

#: ../../../en/example/parametrize.rst:352
msgid "Indirect parametrization"
msgstr ""

#: ../../../en/example/parametrize.rst:354
msgid ""
"Using the ``indirect=True`` parameter when parametrizing a test allows to"
" parametrize a test with a fixture receiving the values before passing "
"them to a test:"
msgstr ""

#: ../../../en/example/parametrize.rst:372
msgid ""
"This can be used, for example, to do more expensive setup at test run "
"time in the fixture, rather than having to run those setup steps at "
"collection time."
msgstr ""

#: ../../../en/example/parametrize.rst:378
msgid "Apply indirect on particular arguments"
msgstr ""

#: ../../../en/example/parametrize.rst:380
msgid ""
"Very often parametrization uses more than one argument name. There is "
"opportunity to apply ``indirect`` parameter on particular arguments. It "
"can be done by passing list or tuple of arguments' names to ``indirect``."
" In the example below there is a function ``test_indirect`` which uses "
"two fixtures: ``x`` and ``y``. Here we give to indirect the list, which "
"contains the name of the fixture ``x``. The indirect parameter will be "
"applied to this argument only, and the value ``a`` will be passed to "
"respective fixture function:"
msgstr ""

#: ../../../en/example/parametrize.rst:409
msgid "The result of this test will be successful:"
msgstr ""

#: ../../../en/example/parametrize.rst:427
msgid "Parametrizing test methods through per-class configuration"
msgstr ""

#: ../../../en/example/parametrize.rst:432
msgid ""
"Here is an example ``pytest_generate_tests`` function implementing a "
"parametrization scheme similar to Michael Foord's `unittest "
"parametrizer`_ but in a lot less code:"
msgstr ""

#: ../../../en/example/parametrize.rst:465
msgid ""
"Our test generator looks up a class-level definition which specifies "
"which argument sets to use for each test function.  Let's run it:"
msgstr ""

#: ../../../en/example/parametrize.rst:487
msgid "Indirect parametrization with multiple fixtures"
msgstr ""

#: ../../../en/example/parametrize.rst:489
msgid ""
"Here is a stripped down real-life example of using parametrized testing "
"for testing serialization of objects between different python "
"interpreters.  We define a ``test_basic_objects`` function which is to be"
" run with different sets of arguments for its three arguments:"
msgstr ""

#: ../../../en/example/parametrize.rst:494
msgid ""
"``python1``: first python interpreter, run to pickle-dump an object to a "
"file"
msgstr ""

#: ../../../en/example/parametrize.rst:495
msgid "``python2``: second interpreter, run to pickle-load an object from a file"
msgstr ""

#: ../../../en/example/parametrize.rst:496
msgid "``obj``: object to be dumped/loaded"
msgstr ""

#: ../../../en/example/parametrize.rst:500
msgid ""
"Running it results in some skips if we don't have all the python "
"interpreters installed and otherwise runs all combinations (3 "
"interpreters times 3 interpreters times 3 objects to "
"serialize/deserialize):"
msgstr ""

#: ../../../en/example/parametrize.rst:513
msgid "Indirect parametrization of optional implementations/imports"
msgstr ""

#: ../../../en/example/parametrize.rst:515
msgid ""
"If you want to compare the outcomes of several implementations of a given"
" API, you can write test functions that receive the already imported "
"implementations and get skipped in case the implementation is not "
"importable/available.  Let's say we have a \"base\" implementation and "
"the other (possibly optimized ones) need to provide similar results:"
msgstr ""

#: ../../../en/example/parametrize.rst:537
msgid "And then a base implementation of a simple function:"
msgstr ""

#: ../../../en/example/parametrize.rst:545
msgid "And an optimized version:"
msgstr ""

#: ../../../en/example/parametrize.rst:553
msgid "And finally a little test module:"
msgstr ""

#: ../../../en/example/parametrize.rst:564
msgid "If you run this with reporting for skips enabled:"
msgstr ""

#: ../../../en/example/parametrize.rst:580
msgid ""
"You'll see that we don't have an ``opt2`` module and thus the second test"
" run of our ``test_func1`` was skipped.  A few notes:"
msgstr ""

#: ../../../en/example/parametrize.rst:583
msgid ""
"the fixture functions in the ``conftest.py`` file are \"session-scoped\" "
"because we don't need to import more than once"
msgstr ""

#: ../../../en/example/parametrize.rst:586
msgid ""
"if you have multiple test functions and a skipped import, you will see "
"the ``[1]`` count increasing in the report"
msgstr ""

#: ../../../en/example/parametrize.rst:589
msgid ""
"you can put :ref:`@pytest.mark.parametrize <@pytest.mark.parametrize>` "
"style parametrization on the test functions to parametrize input/output "
"values as well."
msgstr ""

#: ../../../en/example/parametrize.rst:595
msgid "Set marks or test ID for individual parametrized test"
msgstr ""

#: ../../../en/example/parametrize.rst:597
msgid ""
"Use ``pytest.param`` to apply marks or set test ID to individual "
"parametrized test. For example:"
msgstr ""

#: ../../../en/example/parametrize.rst:620
msgid ""
"In this example, we have 4 parametrized tests. Except for the first test,"
" we mark the rest three parametrized tests with the custom marker "
"``basic``, and for the fourth test we also use the built-in mark "
"``xfail`` to indicate this test is expected to fail. For explicitness, we"
" set test ids for some tests."
msgstr ""

#: ../../../en/example/parametrize.rst:625
msgid "Then run ``pytest`` with verbose mode and with only the ``basic`` marker:"
msgstr ""

#: ../../../en/example/parametrize.rst:642
msgid "As the result:"
msgstr ""

#: ../../../en/example/parametrize.rst:644
msgid "Four tests were collected"
msgstr ""

#: ../../../en/example/parametrize.rst:645
msgid "One test was deselected because it doesn't have the ``basic`` mark."
msgstr ""

#: ../../../en/example/parametrize.rst:646
msgid "Three tests with the ``basic`` mark was selected."
msgstr ""

#: ../../../en/example/parametrize.rst:647
msgid ""
"The test ``test_eval[1+7-8]`` passed, but the name is autogenerated and "
"confusing."
msgstr ""

#: ../../../en/example/parametrize.rst:648
msgid "The test ``test_eval[basic_2+4]`` passed."
msgstr ""

#: ../../../en/example/parametrize.rst:649
msgid "The test ``test_eval[basic_6*9]`` was expected to fail and did fail."
msgstr ""

#: ../../../en/example/parametrize.rst:654
msgid "Parametrizing conditional raising"
msgstr ""

#: ../../../en/example/parametrize.rst:656
msgid ""
"Use :func:`pytest.raises` with the :ref:`pytest.mark.parametrize ref` "
"decorator to write parametrized tests in which some tests raise "
"exceptions and others do not."
msgstr ""

#: ../../../en/example/parametrize.rst:660
msgid "It may be helpful to use ``nullcontext`` as a complement to ``raises``."
msgstr ""

#: ../../../en/example/parametrize.rst:662
msgid "For example:"
msgstr ""

#: ../../../en/example/parametrize.rst:685
msgid ""
"In the example above, the first three test cases should run "
"unexceptionally, while the fourth should raise ``ZeroDivisionError``."
msgstr ""

#: ../../../en/example/pythoncollection.rst:2
msgid "Changing standard (Python) test discovery"
msgstr ""

#: ../../../en/example/pythoncollection.rst:5
msgid "Ignore paths during test collection"
msgstr ""

#: ../../../en/example/pythoncollection.rst:7
msgid ""
"You can easily ignore certain test directories and modules during "
"collection by passing the ``--ignore=path`` option on the cli. ``pytest``"
" allows multiple ``--ignore`` options. Example:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:28
msgid ""
"Now if you invoke ``pytest`` with "
"``--ignore=tests/foobar/test_foobar_03.py --ignore=tests/hello/``, you "
"will see that ``pytest`` only collects test-modules, which do not match "
"the patterns specified:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:46
msgid ""
"The ``--ignore-glob`` option allows to ignore test file paths based on "
"Unix shell-style wildcards. If you want to exclude test-modules that end "
"with ``_01.py``, execute ``pytest`` with ``--ignore-glob='*_01.py'``."
msgstr ""

#: ../../../en/example/pythoncollection.rst:50
msgid "Deselect tests during test collection"
msgstr ""

#: ../../../en/example/pythoncollection.rst:52
msgid ""
"Tests can individually be deselected during collection by passing the "
"``--deselect=item`` option. For example, say "
"``tests/foobar/test_foobar_01.py`` contains ``test_a`` and ``test_b``. "
"You can run all of the tests within ``tests/`` *except* for "
"``tests/foobar/test_foobar_01.py::test_a`` by invoking ``pytest`` with "
"``--deselect tests/foobar/test_foobar_01.py::test_a``. ``pytest`` allows "
"multiple ``--deselect`` options."
msgstr ""

#: ../../../en/example/pythoncollection.rst:59
msgid "Keeping duplicate paths specified from command line"
msgstr ""

#: ../../../en/example/pythoncollection.rst:61
msgid ""
"Default behavior of ``pytest`` is to ignore duplicate paths specified "
"from the command line. Example:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:72
msgid "Just collect tests once."
msgstr ""

#: ../../../en/example/pythoncollection.rst:74
msgid ""
"To collect duplicate tests, use the ``--keep-duplicates`` option on the "
"cli. Example:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:85
msgid ""
"As the collector just works on directories, if you specify twice a single"
" test file, ``pytest`` will still collect it twice, no matter if the "
"``--keep-duplicates`` is not specified. Example:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:99
msgid "Changing directory recursion"
msgstr ""

#: ../../../en/example/pythoncollection.rst:101
msgid ""
"You can set the :confval:`norecursedirs` option in an ini-file, for "
"example your ``pytest.ini`` in the project root directory:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:109
msgid ""
"This would tell ``pytest`` to not recurse into typical subversion or "
"sphinx-build directories or into any ``tmp`` prefixed directory."
msgstr ""

#: ../../../en/example/pythoncollection.rst:114
msgid "Changing naming conventions"
msgstr ""

#: ../../../en/example/pythoncollection.rst:116
msgid ""
"You can configure different naming conventions by setting the "
":confval:`python_files`, :confval:`python_classes` and "
":confval:`python_functions` in your :ref:`configuration file <config file"
" formats>`. Here is an example:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:130
msgid ""
"This would make ``pytest`` look for tests in files that match the "
"``check_* .py`` glob-pattern, ``Check`` prefixes in classes, and "
"functions and methods that match ``*_check``. For example, if we have:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:144
msgid "The test collection would look like this:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:161
msgid ""
"You can check for multiple glob patterns by adding a space between the "
"patterns:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:172
msgid ""
"the ``python_functions`` and ``python_classes`` options has no effect for"
" ``unittest.TestCase`` test discovery because pytest delegates discovery "
"of test case methods to unittest code."
msgstr ""

#: ../../../en/example/pythoncollection.rst:177
msgid "Interpreting cmdline arguments as Python packages"
msgstr ""

#: ../../../en/example/pythoncollection.rst:179
msgid ""
"You can use the ``--pyargs`` option to make ``pytest`` try interpreting "
"arguments as python package names, deriving their file system path and "
"then running the test. For example if you have unittest2 installed you "
"can type:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:188
msgid ""
"which would run the respective test module.  Like with other options, "
"through an ini-file and the :confval:`addopts` option you can make this "
"change more permanently:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:198
msgid ""
"Now a simple invocation of ``pytest NAME`` will check if NAME exists as "
"an importable package/module and otherwise treat it as a filesystem path."
msgstr ""

#: ../../../en/example/pythoncollection.rst:203
msgid "Finding out what is collected"
msgstr ""

#: ../../../en/example/pythoncollection.rst:205
msgid ""
"You can always peek at the collection tree without running tests like "
"this:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:226
msgid "Customizing test collection"
msgstr ""

#: ../../../en/example/pythoncollection.rst:230
msgid ""
"You can easily instruct ``pytest`` to discover tests from every Python "
"file:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:238
msgid ""
"However, many projects will have a ``setup.py`` which they don't want to "
"be imported. Moreover, there may files only importable by a specific "
"python version. For such cases you can dynamically define files to be "
"ignored by listing them in a ``conftest.py`` file:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:252
msgid "and then if you have a module file like this:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:263
msgid "and a ``setup.py`` dummy file like this:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:270
msgid ""
"If you run with a Python 2 interpreter then you will find the one test "
"and will leave out the ``setup.py`` file:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:285
msgid ""
"If you run with a Python 3 interpreter both the one test and the "
"``setup.py`` file will be left out:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:298
msgid ""
"It's also possible to ignore files based on Unix shell-style wildcards by"
" adding patterns to :globalvar:`collect_ignore_glob`."
msgstr ""

#: ../../../en/example/pythoncollection.rst:301
msgid ""
"The following example ``conftest.py`` ignores the file ``setup.py`` and "
"in addition all files that end with ``*_py2.py`` when executed with a "
"Python 3 interpreter:"
msgstr ""

#: ../../../en/example/pythoncollection.rst:314
msgid ""
"Since Pytest 2.6, users can prevent pytest from discovering classes that "
"start with ``Test`` by setting a boolean ``__test__`` attribute to "
"``False``."
msgstr ""

#: ../../../en/example/reportingdemo.rst:4
msgid "Demo of Python failure reports with pytest"
msgstr ""

#: ../../../en/example/reportingdemo.rst:6
msgid "Here is a nice run of several failures and how ``pytest`` presents things:"
msgstr ""

#: ../../../en/example/simple.rst:4
msgid "Basic patterns and examples"
msgstr ""

#: ../../../en/example/simple.rst:7
msgid "How to change command line options defaults"
msgstr ""

#: ../../../en/example/simple.rst:9
msgid ""
"It can be tedious to type the same series of command line options every "
"time you use ``pytest``.  For example, if you always want to see detailed"
" info on skipped and xfailed tests, as well as have terser \"dot\" "
"progress output, you can write it into a configuration file:"
msgstr ""

#: ../../../en/example/simple.rst:21
msgid ""
"Alternatively, you can set a ``PYTEST_ADDOPTS`` environment variable to "
"add command line options while the environment is in use:"
msgstr ""

#: ../../../en/example/simple.rst:28
msgid ""
"Here's how the command-line is built in the presence of ``addopts`` or "
"the environment variable:"
msgstr ""

#: ../../../en/example/simple.rst:34
msgid "So if the user executes in the command-line:"
msgstr ""

#: ../../../en/example/simple.rst:40
msgid "The actual command line executed is:"
msgstr ""

#: ../../../en/example/simple.rst:46
msgid ""
"Note that as usual for other command-line applications, in case of "
"conflicting options the last one wins, so the example above will show "
"verbose output because ``-v`` overwrites ``-q``."
msgstr ""

#: ../../../en/example/simple.rst:53
msgid ""
"Pass different values to a test function, depending on command line "
"options"
msgstr ""

#: ../../../en/example/simple.rst:57
msgid ""
"Suppose we want to write a test that depends on a command line option. "
"Here is a basic pattern to achieve this:"
msgstr ""

#: ../../../en/example/simple.rst:71
msgid ""
"For this to work we need to add a command line option and provide the "
"``cmdopt`` through a :ref:`fixture function <fixture>`:"
msgstr ""

#: ../../../en/example/simple.rst:90
msgid "Let's run this without supplying our new option:"
msgstr ""

#: ../../../en/example/simple.rst:116
msgid "And now with supplying a command line option:"
msgstr ""

#: ../../../en/example/simple.rst:142
msgid "You can see that the command line option arrived in our test."
msgstr ""

#: ../../../en/example/simple.rst:144
msgid "We could add simple validation for the input by listing the choices:"
msgstr ""

#: ../../../en/example/simple.rst:161
msgid "Now we'll get feedback on a bad argument:"
msgstr ""

#: ../../../en/example/simple.rst:170
msgid ""
"If you need to provide more detailed error messages, you can use the "
"``type`` parameter and raise ``pytest.UsageError``:"
msgstr ""

#: ../../../en/example/simple.rst:200
msgid ""
"This completes the basic pattern.  However, one often rather wants to "
"process command line options outside of the test and rather pass in "
"different or more complex objects."
msgstr ""

#: ../../../en/example/simple.rst:205
msgid "Dynamically adding command line options"
msgstr ""

#: ../../../en/example/simple.rst:209
msgid ""
"Through :confval:`addopts` you can statically add command line options "
"for your project.  You can also dynamically modify the command line "
"arguments before they get processed:"
msgstr ""

#: ../../../en/example/simple.rst:226
msgid ""
"If you have the :pypi:`xdist plugin <pytest-xdist>` installed you will "
"now always perform test runs using a number of subprocesses close to your"
" CPU. Running in an empty directory with the above conftest.py:"
msgstr ""

#: ../../../en/example/simple.rst:244
msgid "Control skipping of tests according to command line option"
msgstr ""

#: ../../../en/example/simple.rst:248
msgid ""
"Here is a ``conftest.py`` file adding a ``--runslow`` command line option"
" to control skipping of ``pytest.mark.slow`` marked tests:"
msgstr ""

#: ../../../en/example/simple.rst:277
msgid "We can now write a test module like this:"
msgstr ""

#: ../../../en/example/simple.rst:293
msgid "and when running it will see a skipped \"slow\" test:"
msgstr ""

#: ../../../en/example/simple.rst:309
msgid "Or run it including the ``slow`` marked test:"
msgstr ""

#: ../../../en/example/simple.rst:326
msgid "Writing well integrated assertion helpers"
msgstr ""

#: ../../../en/example/simple.rst:330
msgid ""
"If you have a test helper function called from a test you can use the "
"``pytest.fail`` marker to fail a test with a certain message. The test "
"support function will not show up in the traceback if you set the "
"``__tracebackhide__`` option somewhere in the helper function. Example:"
msgstr ""

#: ../../../en/example/simple.rst:351
msgid ""
"The ``__tracebackhide__`` setting influences ``pytest`` showing of "
"tracebacks: the ``checkconfig`` function will not be shown unless the "
"``--full-trace`` command line option is specified. Let's run our little "
"function:"
msgstr ""

#: ../../../en/example/simple.rst:372
msgid ""
"If you only want to hide certain exceptions, you can set "
"``__tracebackhide__`` to a callable which gets the ``ExceptionInfo`` "
"object. You can for example use this to make sure unexpected exception "
"types aren't hidden:"
msgstr ""

#: ../../../en/example/simple.rst:396
msgid ""
"This will avoid hiding the exception traceback on unrelated exceptions "
"(i.e. bugs in assertion helpers)."
msgstr ""

#: ../../../en/example/simple.rst:401
msgid "Detect if running from within a pytest run"
msgstr ""

#: ../../../en/example/simple.rst:405
msgid ""
"Usually it is a bad idea to make application code behave differently if "
"called from a test.  But if you absolutely must find out if your "
"application code is running from a test you can do something like this:"
msgstr ""

#: ../../../en/example/simple.rst:425
msgid "and then check for the ``your_module._called_from_test`` flag:"
msgstr ""

#: ../../../en/example/simple.rst:436
msgid "accordingly in your application."
msgstr ""

#: ../../../en/example/simple.rst:439
msgid "Adding info to test report header"
msgstr ""

#: ../../../en/example/simple.rst:443
msgid "It's easy to present extra information in a ``pytest`` run:"
msgstr ""

#: ../../../en/example/simple.rst:453
msgid "which will add the string to the test header accordingly:"
msgstr ""

#: ../../../en/example/simple.rst:468
msgid ""
"It is also possible to return a list of strings which will be considered "
"as several lines of information. You may consider "
"``config.getoption('verbose')`` in order to display more information if "
"applicable:"
msgstr ""

#: ../../../en/example/simple.rst:481
msgid "which will add info only when run with \"--v\":"
msgstr ""

#: ../../../en/example/simple.rst:496
msgid "and nothing when run plainly:"
msgstr ""

#: ../../../en/example/simple.rst:509
msgid "Profiling test duration"
msgstr ""

#: ../../../en/example/simple.rst:515
msgid ""
"If you have a slow running large test suite you might want to find out "
"which tests are the slowest. Let's make an artificial test suite:"
msgstr ""

#: ../../../en/example/simple.rst:535
msgid "Now we can profile which test functions execute the slowest:"
msgstr ""

#: ../../../en/example/simple.rst:554
msgid "Incremental testing - test steps"
msgstr ""

#: ../../../en/example/simple.rst:558
msgid ""
"Sometimes you may have a testing situation which consists of a series of "
"test steps.  If one step fails it makes no sense to execute further steps"
" as they are all expected to fail anyway and their tracebacks add no "
"insight.  Here is a simple ``conftest.py`` file which introduces an "
"``incremental`` marker which is to be used on classes:"
msgstr ""

#: ../../../en/example/simple.rst:616
msgid ""
"These two hook implementations work together to abort incremental-marked "
"tests in a class.  Here is a test module example:"
msgstr ""

#: ../../../en/example/simple.rst:641
msgid "If we run this:"
msgstr ""

#: ../../../en/example/simple.rst:668
msgid ""
"We'll see that ``test_deletion`` was not executed because "
"``test_modification`` failed.  It is reported as an \"expected failure\"."
msgstr ""

#: ../../../en/example/simple.rst:673
msgid "Package/Directory-level fixtures (setups)"
msgstr ""

#: ../../../en/example/simple.rst:675
msgid ""
"If you have nested test directories, you can have per-directory fixture "
"scopes by placing fixture functions in a ``conftest.py`` file in that "
"directory. You can use all types of fixtures including :ref:`autouse "
"fixtures <autouse fixtures>` which are the equivalent of xUnit's "
"setup/teardown concept.  It's however recommended to have explicit "
"fixture references in your tests or test classes rather than relying on "
"implicitly executing setup/teardown functions, especially if they are far"
" away from the actual tests."
msgstr ""

#: ../../../en/example/simple.rst:683
msgid "Here is an example for making a ``db`` fixture available in a directory:"
msgstr ""

#: ../../../en/example/simple.rst:699
msgid "and then a test module in that directory:"
msgstr ""

#: ../../../en/example/simple.rst:707
msgid "another test module:"
msgstr ""

#: ../../../en/example/simple.rst:715
msgid ""
"and then a module in a sister directory which will not see the ``db`` "
"fixture:"
msgstr ""

#: ../../../en/example/simple.rst:724
msgid "We can run this:"
msgstr ""

#: ../../../en/example/simple.rst:785
msgid ""
"The two test modules in the ``a`` directory see the same ``db`` fixture "
"instance while the one test in the sister-directory ``b`` doesn't see it."
"  We could of course also define a ``db`` fixture in that sister "
"directory's ``conftest.py`` file. Note that each fixture is only "
"instantiated if there is a test actually needing it (unless you use "
"\"autouse\" fixture which are always executed ahead of the first test "
"executing)."
msgstr ""

#: ../../../en/example/simple.rst:794
msgid "Post-process test reports / failures"
msgstr ""

#: ../../../en/example/simple.rst:796
msgid ""
"If you want to postprocess test reports and need access to the executing "
"environment you can implement a hook that gets called when the test "
"\"report\" object is about to be created.  Here we write out all failing "
"test calls and also access a fixture (if it was used by the test) in case"
" you want to query/look at it during your post processing.  In our case "
"we just write some information out to a ``failures`` file:"
msgstr ""

#: ../../../en/example/simple.rst:831 ../../../en/example/simple.rst:924
msgid "if you then have failing tests:"
msgstr ""

#: ../../../en/example/simple.rst:843
msgid "and run them:"
msgstr ""

#: ../../../en/example/simple.rst:877
msgid "you will have a \"failures\" file which contains the failing test ids:"
msgstr ""

#: ../../../en/example/simple.rst:886
msgid "Making test result information available in fixtures"
msgstr ""

#: ../../../en/example/simple.rst:890
msgid ""
"If you want to make test result reports available in fixture finalizers "
"here is a little example implemented via a local plugin:"
msgstr ""

#: ../../../en/example/simple.rst:949
msgid "and run it:"
msgstr ""

#: ../../../en/example/simple.rst:995
msgid ""
"You'll see that the fixture finalizers could use the precise reporting "
"information."
msgstr ""

#: ../../../en/example/simple.rst:1001
msgid "``PYTEST_CURRENT_TEST`` environment variable"
msgstr ""

#: ../../../en/example/simple.rst:1005
msgid ""
"Sometimes a test session might get stuck and there might be no easy way "
"to figure out which test got stuck, for example if pytest was run in "
"quiet mode (``-q``) or you don't have access to the console output. This "
"is particularly a problem if the problem happens only sporadically, the "
"famous \"flaky\" kind of tests."
msgstr ""

#: ../../../en/example/simple.rst:1009
msgid ""
"``pytest`` sets the :envvar:`PYTEST_CURRENT_TEST` environment variable "
"when running tests, which can be inspected by process monitoring "
"utilities or libraries like :pypi:`psutil` to discover which test got "
"stuck if necessary:"
msgstr ""

#: ../../../en/example/simple.rst:1021
msgid ""
"During the test session pytest will set ``PYTEST_CURRENT_TEST`` to the "
"current test :ref:`nodeid <nodeids>` and the current stage, which can be "
"``setup``, ``call``, or ``teardown``."
msgstr ""

#: ../../../en/example/simple.rst:1025
msgid ""
"For example, when running a single test function named ``test_foo`` from "
"``foo_module.py``, ``PYTEST_CURRENT_TEST`` will be set to:"
msgstr ""

#: ../../../en/example/simple.rst:1028
msgid "``foo_module.py::test_foo (setup)``"
msgstr ""

#: ../../../en/example/simple.rst:1029
msgid "``foo_module.py::test_foo (call)``"
msgstr ""

#: ../../../en/example/simple.rst:1030
msgid "``foo_module.py::test_foo (teardown)``"
msgstr ""

#: ../../../en/example/simple.rst:1032
msgid "In that order."
msgstr ""

#: ../../../en/example/simple.rst:1036
msgid ""
"The contents of ``PYTEST_CURRENT_TEST`` is meant to be human readable and"
" the actual format can be changed between releases (even bug fixes) so it"
" shouldn't be relied on for scripting or automation."
msgstr ""

#: ../../../en/example/simple.rst:1043
msgid "Freezing pytest"
msgstr ""

#: ../../../en/example/simple.rst:1045
msgid ""
"If you freeze your application using a tool like `PyInstaller "
"<https://pyinstaller.readthedocs.io>`_ in order to distribute it to your "
"end-users, it is a good idea to also package your test runner and run "
"your tests using the frozen application. This way packaging errors such "
"as dependencies not being included into the executable can be detected "
"early while also allowing you to send test files to users so they can run"
" them in their machines, which can be useful to obtain more information "
"about a hard to reproduce bug."
msgstr ""

#: ../../../en/example/simple.rst:1053
msgid ""
"Fortunately recent ``PyInstaller`` releases already have a custom hook "
"for pytest, but if you are using another tool to freeze executables such "
"as ``cx_freeze`` or ``py2exe``, you can use ``pytest.freeze_includes()`` "
"to obtain the full list of internal pytest modules. How to configure the "
"tools to find the internal modules varies from tool to tool, however."
msgstr ""

#: ../../../en/example/simple.rst:1059
msgid ""
"Instead of freezing the pytest runner as a separate executable, you can "
"make your frozen program work as the pytest runner by some clever "
"argument handling during program startup. This allows you to have a "
"single executable, which is usually more convenient. Please note that the"
" mechanism for plugin discovery used by pytest (setuptools entry points) "
"doesn't work with frozen executables so pytest can't find any third party"
" plugins automatically. To include third party plugins like ``pytest-"
"timeout`` they must be imported explicitly and passed on to pytest.main."
msgstr ""

#: ../../../en/example/simple.rst:1085
msgid ""
"This allows you to execute tests using the frozen application with "
"standard ``pytest`` command-line options:"
msgstr ""

#: ../../../en/example/special.rst:2
msgid "A session-fixture which can look at all collected tests"
msgstr ""

#: ../../../en/example/special.rst:4
msgid ""
"A session-scoped fixture effectively has access to all collected test "
"items.  Here is an example of a fixture function which walks all "
"collected tests and looks if their test class defines a ``callme`` method"
" and calls it:"
msgstr ""

#: ../../../en/example/special.rst:29
msgid ""
"test classes may now define a ``callme`` method which will be called "
"ahead of running any tests:"
msgstr ""

#: ../../../en/example/special.rst:70
msgid "If you run this without output capturing:"
msgstr ""

